

public class Matrix {
    private double[][] matrix;
    private int row;
    private int col;

    public Matrix(int m, int n) {
        super();
        row = m;
        col = n;
        matrix = new double[m][n];
        MatrixRandomFill();
    }
    
    public Matrix(double[][] m) {
        super();
        row = m.length;
        col = m[0].length;
        matrix = m;
    }

    //Друк матриці
    public void print() {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    //Заповнення матриці
    public void MatrixRandomFill() {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                matrix[i][j] =(int) (Math.random()*40-20);
            }
        }
    }

    //Транспортування матриць
    public void transposition() {
        double[][] result = new double[matrix[0].length][matrix.length];
        for (int i = 0; i < matrix[0].length; i++)
            for (int j = 0; j < matrix.length; j++) {
                result[i][j] = matrix[j][i];
            }
        matrix = result;
    }

    //Множення матриць
    public void multiplication(Matrix other) {
            double[][] result = new double[matrix.length][other.matrix[0].length];
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < other.matrix[0].length; j++) {
                    for (int k = 0; k < other.matrix.length; k++) {
                        result[i][j] += matrix[i][k] * other.matrix[k][j];
                    }
                }
            }
            matrix = result;
        }

    //Складання матриць
    public void drafting(Matrix other) {
        if (matrix.length != other.matrix.length) {
            System.out.println("Довжини матриць нерівні!");
        } else {
            double[][] result = new double[matrix.length][matrix[0].length];
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < matrix[0].length; j++) {
                    result[i][j] = matrix[i][j] + other.matrix[i][j];
                }
            }
            matrix = result;
        }
    }

    //Віднімання матриць
    public void substraction(Matrix other) {
        if (matrix.length != other.matrix.length) {
            System.out.println("Довжини матриць нерівні!");
        } else {
            double[][] result = new double[matrix.length][matrix[0].length];
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < matrix[0].length; j++) {
                    result[i][j] = matrix[i][j] - other.matrix[i][j];
                }
            }
            matrix = result;
        }
    }

    //Множення матриці на вектор
    public void matrixToVector(Vector vector) {
        double[] result = new double[row];
        double res = 0;

        if (matrix[0].length != vector.getVector().length) {
            System.out.println("Дожвина вектора та кількість стовбців матриці не рівні!");
        } else {
            for (int i = 0; i < matrix.length; i++) {
                for (int j = 0; j < vector.getVector().length; j++) {
                    res += matrix[i][j] * vector.getVector()[j];
                }
                result[i] = res;
                res = 0;
            }
            vector.setVector(result);
        }
    }

    //Порівняння матриць
    public void compare(Matrix other) { //метод який виводить результати на екран згідно значень методу elements
        if (elements(other)) {
            System.out.println("Матриці є рівними.");
        } else {
            System.out.println("Матриці не рівні!");
        }
    }

    public boolean elements(Matrix other) { //метод який порівнює матриці і передає результати в метод compare
        if (matrix == other.matrix) {
            return true;
        }
        if (other == null) {
            return false;
        }
        if (col != other.col || row != other.row) {
            return false;
        }
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == other.matrix[i][j]) {
                    continue;
                } else {
                    return false;
                }
            }
        }
        return true;
    }

    //Пошук седлових точок
    public int[] saddle() {
    	    for (int i = 0; i < row; i++) {
            double minRow; //мінімальне число в рядку
            double maxCol; //максимальне число в стовбці
            int[] element=new int[matrix[0].length]; //індекси одинакових мінімальних чисел
            int dubls=1; //кількість одинакових чисел в рядку
            int a=0;

            minRow=matrix[i][0]; //задаю стартове значення числа в рядку(значення першого елемента в рядку)

            for (int j=0; j < matrix[0].length; j++) { //цикл для знаходження мінімального числа в першому рядку
                if(matrix[i][j]<=minRow){ //якщо число менше за задане, то змінюємо його
                    minRow=matrix[i][j]; //заміняю число меншим
                }
            }

            for(int j=0; j<matrix[0].length; j++){  //цикл для визначення кількості одинакових чисел в рядку
                if (matrix[i][j] == minRow) {
                    dubls++;
                }
            }
            
            element=new int[dubls];
            for(int j=0; j<matrix[0].length; j++){ 
                if (matrix[i][j] == minRow) {
                   element[a]=j;
                }
            }

            for(int j=0; j<element.length; j++) { //перевіряє стовбці по всіх одинакових елементах в рядку
                maxCol=matrix[0][(int)element[j]]; //ініціалізую значення 1 елемента в стовбці
                for (int k = 0; k < matrix.length; k++) { //знаходження максимального числа в стовбці
                    if (matrix[k][(int)element[j]] >= maxCol) { //якщо елемент більший за задаше спочатку значення змінюю його
                        maxCol = matrix[k][(int)element[j]]; //заміна стартового значення на більше
                    }
                }
                if(minRow>=maxCol) { //перевірка седлової точки
                  	return new int[] {i, element[j]};
                }
            }
        }
    	    return null;
    }

    //Обчислення норми матриці
    public void norm() {
        double norm = 0; //норма матриці
        for (int i = 0; i < row; i++) {
            double s = 0.0; //норма рядка матриці
            for (int j = 0; j < col; j++) {
                s += Math.abs(matrix[i][j]);
            }
            if (s > norm)
                norm = s;
        }
        System.out.println("Норма матриці: " + norm);
    }

    public void minMax() {
        double max=matrix[0][0];
        double min=matrix[0][0];
        for (int i = 0; i < col; i++) {
            for (int j = 0; j < col; j++) { 
                if (matrix[i][j] > max) { 
                    max = matrix[i][j]; 
                }
                if(matrix[i][j]<min){
                    min=matrix[i][j];
                }
            }
        }
        System.out.println("Макcимальний елемент: " + max);
        System.out.println("Мінімальний елемент: " + min);
    }

}
